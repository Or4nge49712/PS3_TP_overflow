#!/usr/bin/env python3
import json
from ec_utils import (
    N, G,
    point_multiply, mod_inverse
)

def load_firmwares(filename):
    with open(filename, 'r') as f:
        return json.load(f)

def full_attack(fw1, fw2):

    e1 = int(fw1["hash"], 16)
    s1 = int(fw1["signature"]["s"], 16)
    e2 = int(fw2["hash"], 16)
    s2 = int(fw2["signature"]["s"], 16)
    r = int(fw1["signature"]["r"], 16) # r est identique pour les deux

    #Calcul du nonce k
    #(e1 - e2) * inverse_mod(s1 - s2, N) mod N
    num_k = (e1 - e2) % N
    den_k = mod_inverse(s1 - s2, N)
    k = (num_k * den_k) % N

    #Calcul de la clé privée d
    #r^-1 * (k * s1 - e1) mod N
    r_inv = mod_inverse(r, N)
    d = (r_inv * (k * s1 - e1)) % N
    
    return d, k

# =============================================
# Question5 
# =============================================
if __name__ == "__main__":
    
    data = load_firmwares("firmwares.json")
    fw_list = data["firmwares"]
    
    # Récupération de la clé publique attendue pour la vérification
    sony_pub_x = int(data["public_key"]["x"], 16)
    sony_pub_y = int(data["public_key"]["y"], 16)

    print("=== Opération fail0verflow : Phase 3 ===")
    
    #Lancer l'attaque sur les deux premiers firmwares
    d_recupere, k_recupere = full_attack(fw_list[0], fw_list[1])
    
    print(f"[*] Nonce k récupéré : {hex(k_recupere)}")
    print(f"[*] Clé privée d récupérée : {hex(d_recupere)}")

    # On calcule Q' = d * G et on compare avec la clé publique du JSON
    Q_prime = point_multiply(d_recupere, G)
    
    print("\n--- Vérification finale ---")
    if Q_prime.x == sony_pub_x:
        print("Good : La coordonnée Q.x correspond à la clé publique de Sony")
    else:
        print("Fail : La clé privée calculée est incorrecte.")
